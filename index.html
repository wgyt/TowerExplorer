<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" sizes="192x192" href="192x192_App_Icon.png">
    <link rel="apple-touch-icon" sizes="512x512" href="512x512_App_Icon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Explorer | Babylon</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="h-full bg-white dark:bg-gray-900 transition-colors duration-300">
    <div id="app" :class="{'dark': isDarkMode}" class="min-h-screen transition-colors duration-300">
        <!-- å¤´éƒ¨æ§åˆ¶æ  -->
        <header
            class="fixed top-0 left-0 right-0 z-50 dark:bg-gray-900 bg-gray-100 p-4 flex justify-between items-center shadow-md">
            <!-- å·¦ä¾§ï¼šæµåŠ¨æ± é€‰æ‹©å™¨ -->
            <div class="flex-1 max-w-xs">
                <select v-model="selectedPool" @change="handlePoolChange" class="bg-white text-gray-900 border-gray-300  /* æ–°å¢äº®è‰²æ¨¡å¼åŸºç¡€æ ·å¼ */
              dark:bg-gray-800 dark:text-white dark:border-gray-600
              p-2 rounded-lg w-56 border-2  /* åŠ ç²—è¾¹æ¡† */
              mobile:w-32 focus:ring-2 focus:ring-blue-300  /* æ·»åŠ èšç„¦æ•ˆæœ */
              transition-colors duration-200"> <!-- æ·»åŠ è¿‡æ¸¡æ•ˆæœ -->
                    <option v-for="(poolInfo, contractAddress) in pools" :key="contractAddress" :value="contractAddress"
                        class="bg-white dark:bg-gray-800"> <!-- æ·»åŠ é€‰é¡¹èƒŒæ™¯è‰² -->
                        {{ poolInfo.name }}
                    </option>
                </select>
            </div>
            <!-- ä¸­é—´ï¼šåˆ·æ–°æŒ‰é’® -->
            <div class="mx-4">
                <button @click="manualRefresh" class="p-2 rounded-full transition-colors">
                    <svg id="refresh-icon" :key="refreshKey" class="w-6 h-6 text-blue-500 dark:text-blue-400"
                        :class="{ 'animate-spin': loading }" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                </button>
            </div>
            <!-- å³ä¾§ï¼šåŠŸèƒ½æŒ‰é’®ç»„ -->
            <div class="flex items-center gap-3">
                <!-- æš—é»‘æ¨¡å¼åˆ‡æ¢ -->
                <button @click="toggleDarkMode" class="dark:bg-gray-700 bg-gray-200 p-2 rounded-full">
                    <span class="material-icons">{{ isDarkMode ? 'ğŸŒ' : 'ğŸŒ™' }}</span>
                </button>
            </div>
        </header>

        <main class="mt-16 p-4 max-w-6xl mx-auto h-[calc(100vh-80px)]">
            <!-- äº¤æ˜“å†å² -->
            <div v-for="swap in filteredSwaps" :key="swap.transaction"
                class="dark:bg-gray-800 bg-white rounded-lg p-4 mb-4 shadow-md hover:shadow-lg transition-shadow">
                <a :href="`https://babylon.explorers.guru/transaction/${swap.transaction}`" target="_blank"
                    class="block dark:text-blue-400 text-blue-600 hover:underline">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-gray-600 dark:text-gray-400 text-sm">
                            {{ getTimeDisplay(swap.timestamp) }}
                        </span>
                        <span class="text-sm dark:text-gray-400">
                            {{ truncateAddress(swap.sender) }}
                        </span>
                    </div>
                    <div class="flex justify-between items-center">
                        <!-- å·¦ä¾§è´Ÿæ•°æ˜¾ç¤º -->
                        <div class="text-red-500 text-left flex-1">
                            <div class="mb-1 last:mb-0">
                                -{{ swap.input.amount }} {{ swap.input.denom.symbol }}
                            </div>
                        </div>

                        <div class="text-mid">
                            <p class="text-sm font-mono">
                                {{ calculatePrice(swap) }}
                            </p>
                            <p class="text-sm text-gray-500 dark:text-gray-400">
                                {{ swap.height }}
                            </p>
                        </div>

                        <!-- å³ä¾§æ­£æ•°æ˜¾ç¤º -->
                        <div class="text-green-500 text-right flex-1">
                            <div class="mb-1 last:mb-0">
                                {{ swap.output.amount }} {{ swap.output.denom.symbol }}
                            </div>
                        </div>
                    </div>
                </a>
            </div>
            <div v-if="loading" class="text-center dark:text-gray-400">åŠ è½½ä¸­...</div>
            <div v-if="!hasMore" class="text-center dark:text-gray-400">æ²¡æœ‰æ›´å¤šäº¤æ˜“è®°å½•</div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    refreshKey: 0, // æ–°å¢åˆ·æ–°æŒ‰é’®åŠ¨ç”»æ§åˆ¶å¯†é’¥,å¼ºåˆ¶é‡æ–°åˆ›å»ºSVGå…ƒç´ 
                    currentTime: Date.now(),
                    isDarkMode: true,
                    pools: {
                        'bbn1qjn06jt7zjhdqxgud07nylkpgnaurq6x6vad38vztwxec4rr5ntsnn4dd3': { name: 'BABY/USDC Â· XYK Â· 0.3%', quote: 'ibc/65D0BEC6DAD96C7F5043D1E54E54B6BB5D5B3AEC3FF6CEBB75B9E059F3580EA3' },
                        'bbn1n9jy4xlk00p2w2rdeumxznzsxrphx8lh95v39g0wkslchpmaqcvsyyxqu4': { name: 'BABY/LBTC Â· XYK Â· 0.3%', quote: 'ibc/89EE10FCF78800B572BAAC7080AEFA301B5F3BBC51C5371E907EB129C5B900E7' }
                    },
                    selectedPool: "bbn1qjn06jt7zjhdqxgud07nylkpgnaurq6x6vad38vztwxec4rr5ntsnn4dd3",
                    assets: { // èµ„äº§æ˜ å°„è¡¨
                        'ubbn': { symbol: 'BABY', addr: 'ubbn', decimal: 6 },
                        'ibc/65D0BEC6DAD96C7F5043D1E54E54B6BB5D5B3AEC3FF6CEBB75B9E059F3580EA3': { symbol: 'USDC', addr: 'ibc/65D0BEC6DAD96C7F5043D1E54E54B6BB5D5B3AEC3FF6CEBB75B9E059F3580EA3', decimal: 6 },
                        'ibc/89EE10FCF78800B572BAAC7080AEFA301B5F3BBC51C5371E907EB129C5B900E7': { symbol: 'LBTC', addr: 'ibc/89EE10FCF78800B572BAAC7080AEFA301B5F3BBC51C5371E907EB129C5B900E7', decimal: 8 }
                    },
                    allLCDNodes: ["https://babylon.nodes.guru/api", "https://babylon-api.polkachu.com", "https://babylon-rest.publicnode.com"],
                    swaps: [],
                    page: 0,
                    loading: false,
                    isDarkMode: localStorage.getItem('darkMode') === 'true' ||
                        (window.matchMedia('(prefers-color-scheme: dark)').matches &&
                            !localStorage.getItem('darkMode')),
                    hasMore: true,
                    scrollHandler: null,
                    existingHashes: new Set(), // ç”¨äºå­˜å‚¨å·²å­˜åœ¨çš„äº¤æ˜“å“ˆå¸Œ,é˜²æ­¢è¯·æ±‚åˆ†é¡µæ•°æ®å‡ºç°é‡å¤
                }
            },
            mounted() {
                // å¯åŠ¨æ—¶é—´æ›´æ–°å®šæ—¶å™¨
                this.timeInterval = setInterval(() => {
                    this.currentTime = Date.now();
                }, 1000);
            },
            beforeUnmount() {
                clearInterval(this.timeInterval);
                window.removeEventListener('scroll', this.scrollHandler);
            },
            computed: {
                filteredSwaps() {
                    return [...this.swaps].sort(this.compareSwaps);
                }
            },
            watch: {
                isDarkMode(newVal) {
                    this.applyDarkMode(newVal);
                }
            },
            async mounted() {
                this.scrollHandler = this.handleScroll.bind(this);
                window.addEventListener('scroll', this.scrollHandler);
                this.applyDarkMode(this.isDarkMode);
                await this.loadSwaps();
            },
            methods: {
                compareSwaps(a, b) {
                    // ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šæŒ‰åŒºå—é«˜åº¦é™åº
                    if (b.height !== a.height) {
                        return b.height - a.height;
                    }

                    if (a.price == 'N/A') {
                        return -1;
                    }

                    if (b.price == 'N/A') {
                        return 1;
                    }

                    // ç¬¬äºŒä¼˜å…ˆçº§ï¼šäº¤æ˜“æ–¹å‘
                    const sideOrder = { 'ä¹°': 1, 'å–': 2 };
                    if (a.side !== b.side) {
                        return sideOrder[a.side] - sideOrder[b.side];
                    }

                    // ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šä»·æ ¼æ’åºï¼ˆä¹°å•é«˜ä»·ä¼˜å…ˆï¼Œå–å•ä½ä»·ä¼˜å…ˆï¼‰
                    if (a.side === 'ä¹°') {
                        return b.price - a.price; // ä¹°å•é™åº
                    } else {
                        return a.price - b.price; // å–å•å‡åº
                    }
                },
                // æ–°å¢changeäº‹ä»¶å¤„ç†
                async handlePoolChange(event) {
                    console.log(this.selectedPool);
                    if (this.loading) return;

                    // æ¸…ç©ºå½“å‰æ•°æ®
                    this.swaps = [];

                    // æ›´æ–°æµè§ˆå™¨å†å²è®°å½•
                    // const newURL = new URL(window.location.href);
                    // newURL.searchParams.set('pool', this.selectedPool);
                    // window.history.replaceState({}, '', newURL);

                    // å‘èµ·æ•°æ®è¯·æ±‚
                    this.currentTime = Date.now();
                    await this.loadSwaps(true);
                },

                hasValidSwapMessage(messages) {
                    return messages.some(msg => {
                        const prefix = '/cosmwasm.wasm.v1.MsgExecuteContract:';
                        return msg.startsWith(prefix) &&
                            msg.slice(prefix.length).includes('swap');
                    });
                },

                parseMsgTypes(messages) {
                    return messages
                        .map(msg => {
                            const prefix = '/cosmwasm.wasm.v1.MsgExecuteContract:';
                            return msg.startsWith(prefix) ? msg.slice(prefix.length) : null;
                        })
                        .filter(msgType => msgType && msgType.includes('swap'));
                },

                async loadSwaps(isRefresh = false, page = 0, limit = 25) {
                    if (isRefresh) {
                        this.existingHashes.clear(); // é‡ç½®æ—¶æ¸…ç©ºå“ˆå¸Œé›†åˆ
                        this.page = 0;
                        this.hasMore = true;
                        this.swaps = [];
                    }
                    if (this.loading || !this.selectedPool || !this.hasMore) return;

                    this.loading = true;
                    try {
                        // è·å–äº¤æ˜“åˆ—è¡¨
                        const response = await fetch(
                            `https://babylon.api.explorers.guru/api/v1/cosmwasm/contracts/${this.selectedPool}/txs?page=${page}&limit=${limit}`,
                            {
                                headers: {
                                    'accept': '*/*',
                                    'user-agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36'
                                }
                            }
                        );

                        const txList = await response.json();
                        // æ£€æµ‹æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
                        this.hasMore = txList.data.length >= limit;
                        this.rawData = txList.data.filter(tx => {
                            // å·²ç»å­˜åœ¨äº†ä¹Ÿä¸ç”¨å¤„ç†äº†
                            if (this.existingHashes.has(tx.hash)) {
                                return false;
                            }
                            // ä¸å­˜åœ¨,å…ˆåŠ å…¥é›†åˆ,å†åˆ¤æ–­æ˜¯å¦åŒ…å«æœ‰æ•ˆæ¶ˆæ¯
                            this.existingHashes.add(tx.hash);
                            return this.hasValidSwapMessage(tx.messages);
                        });

                        // å¹¶è¡Œè·å–äº¤æ˜“è¯¦æƒ…
                        const txDetails = await Promise.all(
                            this.rawData.map(tx =>
                                fetch(`${this.allLCDNodes[Math.floor(Math.random() * this.allLCDNodes.length)]}/cosmos/tx/v1beta1/txs/${tx.hash}`)
                                    .then(r => r.json())
                                    .catch(() => null)
                            )
                        );

                        const newSwaps = txDetails.map(swap => this.parseSwapDetails(swap));
                        console.log(newSwaps);

                        if (newSwaps.length) {
                            this.swaps = [...this.swaps, ...newSwaps];
                        }
                    } catch (error) {
                        console.error('åŠ è½½äº¤æ˜“å¤±è´¥:', error);
                        alert('äº¤æ˜“è®°å½•åŠ è½½å¤±è´¥');
                    } finally {
                        this.loading = false;
                    }
                },

                /**
                 * å°†åŸå§‹é“¾ä¸Šé‡‘é¢è½¬æ¢ä¸ºå¯è¯»æ ¼å¼
                 * @param {string} amountStr åŸå§‹é‡‘é¢å­—ç¬¦ä¸²
                 * @param {int} decimal èµ„äº§decimal
                 * @returns {string} æ ¼å¼åŒ–åçš„é‡‘é¢
                 */
                formatTokenAmount(amountStr, decimal = 6) {
                    try {
                        // å¤„ç†ç§‘å­¦è®¡æ•°æ³•ï¼ˆå¦‚æœæœ‰ï¼‰
                        let amount = amountStr.includes('e')
                            ? BigInt(amountStr.split('e')[0]) * (10n ** BigInt(amountStr.split('e')[1]))
                            : BigInt(amountStr);

                        const divisor = 10n ** BigInt(decimal);
                        const integerPart = amount / divisor;
                        const fractionalPart = amount % divisor;

                        // æ ¼å¼åŒ–å°æ•°éƒ¨åˆ†ï¼ˆè¡¥å‰å¯¼é›¶ï¼‰
                        const fractionalStr = fractionalPart.toString()
                            .padStart(decimal, '0')
                            .replace(/0+$/, ''); // ç§»é™¤å°¾éƒ¨æ— æ•ˆé›¶

                        return fractionalStr.length > 0
                            ? `${integerPart}.${fractionalStr}`
                            : integerPart.toString();
                    } catch (e) {
                        console.error(`é‡‘é¢æ ¼å¼åŒ–å¤±è´¥: ${amountStr} `, e);
                        return '0';
                    }
                },

                parseSwapDetails(txDetail) {
                    // åˆå§‹åŒ–é»˜è®¤å€¼
                    const result = {
                        transaction: txDetail.tx_response.txhash,
                        height: 0,
                        timestamp: new Date(txDetail.tx_response.timestamp).getTime(),
                        sender: '',
                        action: 'UNKNOWN',
                        code: 0,
                        input: { amount: '0', denom: 'UNKNOWN' },
                        output: { amount: '0', denom: 'UNKNOWN' },
                        side: '',
                        price: 0,
                    };

                    try {
                        // è§£æäº¤æ˜“ç±»å‹
                        result.action = Object.keys(txDetail.tx.body.messages[0].msg)[0];
                        result.height = txDetail.tx_response.height;
                        result.code = txDetail.tx_response.code;
                        // è§£æå‘é€è€…åœ°å€
                        if (txDetail.tx.body.messages?.length > 0) {
                            result.sender = txDetail.tx.body.messages[0].sender;
                        }

                        // éå†äº‹ä»¶
                        const swapEvents = txDetail.tx_response.events.filter(e =>
                            e.type === 'wasm-swap' &&
                            e.attributes.some(attr =>
                                attr.key === '_contract_address' &&
                                attr.value === this.selectedPool
                            )
                        );

                        // æå–å…³é”®å±æ€§
                        for (const event of swapEvents) {
                            const attributes = event.attributes.reduce((acc, attr) => {
                                acc[attr.key] = attr.value;
                                return acc;
                            }, {});

                            // è§£æè¾“å…¥è¾“å‡º
                            if (attributes.offer_asset && attributes.offer_amount) {
                                result.input = {
                                    amount: this.formatTokenAmount(attributes.offer_amount, this.assets[attributes.offer_asset].decimal),
                                    denom: this.assets[attributes.offer_asset] || attributes.offer_asset
                                };
                            }

                            if (result.code == 0 && attributes.ask_asset && attributes.return_amount) {
                                result.output = {
                                    amount: this.formatTokenAmount(attributes.return_amount, this.assets[attributes.ask_asset].decimal),
                                    denom: this.assets[attributes.ask_asset] || attributes.ask_asset
                                };
                            }

                            if (txDetail.tx_response.txhash == "BD443D333BF2E2A0696D1C56C89B59DBFA4C795F6ED4EB68FD22254A9CB0EEE1") {
                                console.log(txDetail.tx.body.messages);
                            }
                        }
                        // ä¼˜å…ˆä½¿ç”¨fundsæ•°æ®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        if (txDetail.tx.body.messages[0]?.funds?.length > 0) {
                            const fund = txDetail.tx.body.messages[0].funds[0];
                            result.input = {
                                amount: this.formatTokenAmount(fund.amount, this.assets[fund.denom].decimal),
                                denom: this.assets[fund.denom] || fund.denom
                            };
                        }

                        const inputAmt = Math.abs(parseFloat(result.input.amount));
                        const outputAmt = Math.abs(parseFloat(result.output.amount));

                        // å¤„ç†é›¶å€¼é—®é¢˜
                        if (inputAmt === 0 || outputAmt === 0) {
                            result.price = 'N/A';
                        } else {
                            // inputæ˜¯è®¡ä»·token
                            if (result.input.denom.addr == this.pools[this.selectedPool].quote) {
                                result.price = inputAmt / outputAmt;
                                result.side = "ä¹°";
                            } else {
                                result.price = outputAmt / inputAmt;
                                result.side = "å–";
                            }
                        }
                    } catch (e) {
                        console.error('è§£æé”™è¯¯:', e);
                    }

                    return result;
                },

                truncateAddress(address) {
                    if (window.innerWidth < 768) {
                        return `${address.slice(0, 6)}...${address.slice(-4)}`;
                    }
                    return address;
                },

                formatTime(timestamp) {
                    const date = new Date(timestamp);
                    return date.toLocaleTimeString('zh-CN', {
                        hour12: false,
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                },

                // æ–°å¢ç›¸å¯¹æ—¶é—´æ ¼å¼åŒ–æ–¹æ³•
                formatDuration(seconds) {
                    const units = [
                        { value: 86400, label: 'å¤©' },
                        { value: 3600, label: 'å°æ—¶' },
                        { value: 60, label: 'åˆ†' },
                        { value: 1, label: 'ç§’' }
                    ];

                    let output = [];
                    let remaining = seconds;

                    units.forEach(({ value, label }) => {
                        const count = Math.floor(remaining / value);
                        if (count > 0 || output.length > 0) {
                            output.push(`${count}${label}`);
                            remaining %= value;
                        }
                    });

                    return output.join('') + 'å‰';
                },

                // æ›´æ–°åçš„æ—¶é—´æ˜¾ç¤ºæ–¹æ³•
                getTimeDisplay(timestamp) {
                    const dateStr = this.formatTime(timestamp);
                    const duration = this.formatDuration(
                        Math.floor((this.currentTime - timestamp) / 1000)
                    );
                    return `${dateStr} (${duration})`;
                },

                toggleDarkMode() {
                    this.isDarkMode = !this.isDarkMode;
                    localStorage.setItem('darkMode', this.isDarkMode);
                },

                applyDarkMode(isDark) {
                    if (isDark) {
                        document.documentElement.classList.add('dark');
                        document.body.classList.add('dark:bg-gray-900');
                    } else {
                        document.documentElement.classList.remove('dark');
                        document.body.classList.remove('dark:bg-gray-900');
                    }
                },

                handleSystemThemeChange(event) {
                    if (!localStorage.getItem('darkMode')) {
                        this.isDarkMode = event.matches;
                    }
                },

                // æ–°å¢ä»·æ ¼è®¡ç®—æ–¹æ³•
                calculatePrice(swap) {
                    if (swap.code != 0) {
                        return `FAIL`;
                    }
                    return this.formatPrice(swap.price);
                },

                // ä»·æ ¼æ ¼å¼åŒ–æ–¹æ³•
                formatPrice(value) {
                    if (value >= 1000) {
                        return value.toExponential(2);
                    }
                    if (value >= 0.01) {
                        return value.toFixed(4).replace(/\.?0+$/, '');
                    }
                    return value.toExponential(3);
                },

                // æ–°å¢æ‰‹åŠ¨åˆ·æ–°æ–¹æ³•
                async manualRefresh() {
                    if (this.loading) return;

                    this.refreshKey++; // å¼ºåˆ¶é‡æ–°æ¸²æŸ“å›¾æ ‡
                    try {
                        this.currentTime = Date.now();
                        await this.loadSwaps(true, 0, 15);
                    } catch (error) {
                        console.error('åˆ·æ–°å¤±è´¥:', error);
                    }
                },

                async handleScroll() {
                    // ç²¾ç¡®è®¡ç®—æ»šåŠ¨ä½ç½®
                    const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
                    const isBottom = scrollTop + clientHeight >= scrollHeight - 100; // è·ç¦»åº•éƒ¨100pxè§¦å‘

                    if (isBottom && !this.loading && this.hasMore) {
                        this.loadNextPage();
                    }
                },

                async loadNextPage() {
                    this.page++;
                    await this.loadSwaps(false, this.page, 15);
                },
            }
        }).mount('#app');
    </script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            // å…¶ä»–é…ç½®...
        }
    </script>

    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a202c;
                color: #e2e8f0;
            }
        }

        @media (prefers-color-scheme: light) {
            body {
                background-color: #fff;
                color: #2d3748;
            }
        }

        .dark body {
            background-color: #1a202c;
            color: #e2e8f0;
        }

        .mobile\:grid-cols-1 {
            @media (max-width: 768px) {
                grid-template-columns: 1fr;
            }
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .animate-spin {
            animation: spin 0.8s linear;
            animation-fill-mode: forwards;
        }

        .transaction-container {
            -webkit-overflow-scrolling: touch;
        }

        /* è°ƒæ•´ç§»åŠ¨ç«¯å¸ƒå±€ */
        @media (max-width: 640px) {
            main {
                margin-top: 12px;
                padding-top: 4rem;
                /* å‡å°é¡¶éƒ¨é—´è· */
                height: calc(100vh - 60px);
                /* è°ƒæ•´é«˜åº¦ */
            }

            header {
                padding: 0.5rem;
            }
        }

        /* æ»šåŠ¨æ¡ç¾åŒ– */
        main::-webkit-scrollbar {
            width: 6px;
        }

        main::-webkit-scrollbar-track {
            @apply bg-gray-100 dark:bg-gray-800;
        }

        main::-webkit-scrollbar-thumb {
            @apply bg-gray-300 dark:bg-gray-600 rounded-full;
        }
    </style>
</body>

</html>